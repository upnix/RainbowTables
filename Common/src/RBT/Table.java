package RBT;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.LinkedList;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.ThreadLocalRandom;
import org.msgpack.core.MessagePack;
import org.msgpack.core.MessagePacker;
import org.msgpack.core.MessageUnpacker;

/**
 * Loads or generates a rainbow table, given expected parameters in <code>Config</code> object.
 * Also contains static <code>Table</code> helper functions.
 *
 * @see Config
 * @see Search
 * @author Chris Cameron
 */
public class Table {
  /** Displays extra table generation data. */
  static final boolean DEBUG = true;

  /** Length of the hash generated by the hashing algorithm (SHA-1). */
  public static final int HASHLEN = 40;
  /** Allowable characters in the plain-text key space. */
//  public static final Character[] ALLOWABLE_CHARS = {
//      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
//      't', 'u', 'v', 'w', 'x', 'y', 'z'
//  };
//  public static final Character[] ALLOWABLE_CHARS = {
//      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
//      't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
//  };
    public static final Character[] ALLOWABLE_CHARS = {
      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
      't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
      'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
  };
//    public static final Character[] ALLOWABLE_CHARS = {
//      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
//      't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
//      'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4',
//      '5', '6', '7', '8', '9'
//  };
  //  public static final Character[] ALLOWABLE_CHARS = {
//      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's',
//      't', 'u', 'v', 'w', 'x', 'y', 'z'
//  };

  // Rainbow table chains to be populated
  /**
   * List of <code>TreeMap</code>'s that contain plain-text keys to hashes in
   * <code>byte[]</code> form.
   * @see java.util.TreeMap
   */
  List<TreeMap<String, byte[]>> keyToHashMap = new LinkedList<>();
  /**
   * List of <code>TreeMap</code>'s that contain hashes in <code>byte[]</code> form to
   * plain-text keys.
   * @see java.util.TreeMap
   */
  List<TreeMap<byte[], String>> hashToKeyMap = new LinkedList<>();

  /** Simple name for a default parameter from <code>Config</code> object. */
  int keyLength;
  /** Simple name for a default parameter from <code>Config</code> object. */
  int chainLength;
  /** Simple name for a default parameter from <code>Config</code> object. */
  long tableLength;
  /**
   * A count of all possible keys, given <code>keyLength</code> and <code>ALLOWABLE_CHARS</code>.
   * @see #keyLength
   * @see #ALLOWABLE_CHARS
   * */
  long keySpace;
  /** Location of the serialized <code>TreeMap</code> tables. */
  String fileName;

  static MessageDigest shaHash;
  static {
    try {
      shaHash = MessageDigest.getInstance("SHA-1");
    } catch(Exception e) {
      System.exit(-1);
    }
  }


  /**
   * Constructs a rainbow table using parameters from <code>cfg</code>.
   * @param cfg Configuration parameters
   */
  Table(Config cfg) {
    keyToHashMap.add(new TreeMap<>());
    keyToHashMap.add(new TreeMap<>());

    hashToKeyMap.add(new TreeMap<>(new ByteArrayComparator()));
    hashToKeyMap.add(new TreeMap<>(new ByteArrayComparator()));

    keyLength = cfg.getKeyLen();
    chainLength = cfg.getChainLen();
    tableLength = cfg.getTblLen();
    keySpace = (long) Math.pow(ALLOWABLE_CHARS.length, keyLength);

    /*
     * Generate the file name a previously generated rainbow table would have
     * used, given the parameters set. May or may not exist.
     */
    // Create a string of configuration parameters, and hash that string for file name
    String cfgString =
        Arrays.deepToString(ALLOWABLE_CHARS)
            + keyLength
            + chainLength
            + tableLength;
    fileName = "RT_" + cfgString.hashCode() + ".ser";

    // Load the rainbow table represented by 'cfgString', if it exists, otherwise compute it.
    if (existsTableFile()) {
      readTableFile();
    } else {
      // Create and load table
      generateTable(tableLength);
      // Put new table on disk for next time
      writeTableFile();
    }
  }

  // PROTECTED, STATIC
  /**
   * Converts a byte array to hex for familiar looking SHA-1 hashes.<br>
   * Credit to: https://stackoverflow.com/a/311179/3846437
   * @param b byte[] of length 20
   * @return Hex string of 40-characters
   */
  protected static String byteArrayToHexString(byte[] b) {
    String result = "";
    for (int i = 0; i < b.length; i++) {
      result += Integer.toString((b[i] & 0xff) + 0x100, 16).substring(1);
    }
    return result;
  }

  /**
   * Converts a hex string representing an SHA-1 hash to a <code>byte[]</code>.
   * This is compatible with what {@link java.security.MessageDigest#digest()} returns.
   * @see MessageDigest#digest()
   * @param s Hex string of 40-characters
   * @return byte[] of length 20
   */
  protected static byte[] hexStringToByteArray(String s) {
    byte[] result = new byte[(s.length()/2)];
    int front = 0; // Front position in String 's'
    int back = 2; // Rear position in String 's'
    // Step through String 's', 2 characters at a time
    for(int i = 0; i < (s.length()/2); i++) {
      String hex = s.substring(front, back); // Two characters from 's'
      result[i] = (byte)Integer.parseInt(hex, 16);
      front = back;
      back += 2;
    }

    return result;
  }

  /**
   * Creates an SHA-1 hash of supplied string in <code>byte[]</code> form.
   * Uses {@link java.security.MessageDigest#digest()}.
   * @see java.security.MessageDigest#digest()
   * @param plaintext String to hash
   * @return byte[] of length 20
   */
  protected static byte[] createShaHash(String plaintext) {
    shaHash.update(plaintext.getBytes());

    return shaHash.digest();
  }

  /**
   * Reduce then hash, <code>n</code> times. Static version.<br>
   * This method takes a hash, treats it as if it were at some location on a chain, and then
   * runs it along the chain until the final position.<br>
   * So, consider steps ('n') to be counted <b><i>from the right side of the chain</i></b>.<p>
   * For example, with a chain of - K1:H1:K2:H2:K3:H3:...:K10:H10
   * n = 3 would be three in from the right.
   * This places 'plaintext' as the position of hashToKeyMap(hash, 6, 5), or the 7th chain from
   * the left in a chain of length 10.
   * salt = 10 - 3 - 1 = 6</p>
   * @param initialHash Starting hash value
   * @param n Number of times to hash, reduce
   * @param cl Chain length
   * @param kl Key length
   * @return Hash in byte[] form that is 'n' steps from 'initialHash'
   */
  protected static byte[] hashToHashStep(byte[] initialHash, int n, int cl, int kl) {
    // Being asked to make 0 steps
    if(n == 0) {
      return initialHash;
    }
    // Prevent stepping off the end of the chain
    if (n > cl - 1) {
      System.out.println("Trying to hash/reduce off chain");
      System.exit(-1);
    }
    int salt = cl - n - 1; // Appropriate salt for present chain location
    byte[] hash = initialHash; // Holds hash that's ultimately returned
    // Reduce (hashToKeyMap) then hash (createShaHash) 'n' times
    for (int i = 0; i < n; i++) {
      hash = createShaHash(Table.hashToKey(hash, salt, kl));
      salt++;
    }

    return hash;
  }

  /**
   * Hash reduction algorithm. Produces different results depending on supplied <code>salt</code>.
   * Static version.<br>
   * When considered against the *Step() methods, this could be considered a single step.
   * @param hash Hash in byte[] form
   * @param salt int that acts as modifier to method's output
   * @param kl Key length
   * @return Plain-text key
   */
  protected static String hashToKey(byte[] hash, int salt, int kl) {
    String reducedKey = ""; // String we will produce from 'hash'

    // 'salt' will range from 0 to (chainLength-1). When ALLOWABLE_CHARS.length < chainLength
    // 'salt' can grow to be larger than the number of allowable characters. We want to avoid the
    // scenario where salt%ALLOWABLE_CHARS.length wraps around to a value that has already been
    // seen. Should this happen we'll only have ALLOWABLE_CHARS.length unique reduction functions,
    // rather than chainLength-1. Here I attempt to solve this.
    if(salt >= ALLOWABLE_CHARS.length) {
      salt += salt%ALLOWABLE_CHARS.length+1;
    }

    // TODO: Different implementation.
    // Slower than the one below, doesn't seem to generate as many matching
    // keys somehow? I like it because it seems cleaner. Will come back to.
    // BigInteger hashAsInt = new BigInteger(hash, 16);
    // BigInteger keySpaceBI = new BigInteger(Long.toString(keySpace));
    // long hashMod = hashAsInt.mod(keySpaceBI).longValue();

    // for(int i = 0; i < kl; i++) {
    // 	long divisor = (long)Math.pow(ALLOWABLE_CHARS.length, i);
    // 	long modDividend = (long)(hashMod/divisor)+salt;
    // 	reducedKey += ALLOWABLE_CHARS[(int)(modDividend%ALLOWABLE_CHARS.length)];
    // }
    // System.out.println(reducedKey);

    /* The length of the hash is divided by the plain-text key length, and stored in 'chunks'.
     * The remainder is stored in 'extra'.
     * The 'byte' elements of the hash are divided evenly among "'chunks' number"
     * of bins, with 1 character from 'extra' added to each bin until none remain.
     * Each byte in a bin is XOR'd with one another (intended to create a unique result), 0xff is
     * added (ensures a positive integer), 'salt' is added, then modular arithmetic used to take
     * the new integer and turn it into a character appropriate for the keyspace.
     */

    int chunks = hash.length / kl; // Integer division
    int extra = hash.length % chunks;

    int strStart; // Start bound of hash substring
    int strEnd = 0; // End bound of hash substring
    // The number of positions in a plain-text key (kl) dictate how byte's in 'hash' are grouped
    for (int i = 0; i < kl; i++) {
      strStart = strEnd;
      if (extra > 0) {
        // Include one extra byte
        strEnd = strStart + chunks + 1;
        extra--;
      } else {
        strEnd = strStart + chunks;
      }

      byte subByte = 0;
      // Step through bytes for this group, XORing with 'subByte'
      for(int k = strStart; k < strEnd; k++) {
        subByte ^= hash[k];
      }
      // TODO: Replace with StringBuilder, although I question the value of this currently
      reducedKey += ALLOWABLE_CHARS[((subByte&0xff) + salt) % ALLOWABLE_CHARS.length];
    }

    return reducedKey;
  }

  /**
   * Performs basic checks that supplied hash is valid.
   * @param hash Supplied hash in byte[] form
   * @return Validity of hash
   */
  protected static boolean isValidHexHash(String hash) {
    // Is the length equal to 'HASHLEN'? Is it proper hexadecimal?
    return hash.matches("^[a-f0-9]{" + HASHLEN + "}");
  }

  /**
   * Hash, reduce, n times, along a chain that starts with <code>initialKey</code>.
   * Static version.<br>
   * 'n' is a location on the chain, <b><i>when counting from left to right</i></b>, which should
   * point to the location of a target key (which isn't held in this method). The intent is that,
   * given the head of the chain, 'initialKey', 'n' steps in will be the particular key that the
   * caller is looking for.
   *
   * @param initialKey Initial plain-text key
   * @param n Number of times to hash, reduce
   * @param cl Chain length
   * @param kl Key length
   * @return Result of 'n' hash, reduce steps
   */
  protected static String keyToKeyStep(String initialKey, int n, int cl, int kl) {
    // Prevent stepping off the end of the chain
    if (n > cl - 1) {
      System.out.println("Trying to reduce/hash off chain");
      System.exit(-1);
    }
    String key = initialKey; // Key that's ultimately returned
    // Hash (createShaHash) then reduce (hashToKey) 'n' times
    for (int i = 0; i < n; i++) {
      key = Table.hashToKey(createShaHash(key), i, kl);
    }

    return key;
  }

  // PUBLIC
  /** Prints table information summary. */
  public void printSummary() {
    System.out.println("Rainbow table loaded with the following parameters:");
    System.out.println("  Configured -");
    // FIXME
//    System.out.printf("    * %13s: %,d%n", "Table length", hashToKeyMap[0].size());
    System.out.printf("    * %13s: %,d%n", "Chain length", chainLength);
    System.out.printf("    * %13s: %,d%n", "Key length", keyLength);
    System.out.println();
    System.out.println("  Static -");
    System.out.printf("    * %13s: %,d%n", "Key space size", keySpace);
    System.out.printf("    * %13s:%n", "Allowable character set");
    // TODO: I know this output looks bad, but it appears the effort to wrap the output is more
    // trouble than it's worth right now.
    System.out.println(Arrays.deepToString(ALLOWABLE_CHARS));
    System.out.println();
  }

  // PROTECTED
  /**
   * Create a rainbow table of length <code>num</code>.
   * @param num Length of table generated
   */
  protected void generateTable(long num) {
    if(DEBUG) {
      System.out.format("Generating table of size %,d%n", num);
      System.out.format("%s\t%s\t%s\t%s\t%s%n",
          "Elapsed", "Rows remaining", "Rows complete/time", "Collisions", "Successful H/s");
    }
    long startTime = currentTimeSeconds();
    long curTime = startTime; // Time since current round was started
    long printTime = 30; // Print every 30 seconds
    int totalCollisions = 0;
    int prevCollisions = 0; // Key collisions from the previous round
    long prevNum = num; // 'num' from previous round
    while (num > 0) {
      // DEBUG is set and time since last round started is >= printTime
      if(DEBUG && ((currentTimeSeconds())-curTime) >= printTime) {
        // "Elapsed", "Rows remaining", "Rows complete/time", "Collisions", "Successful H/s"
        System.out.format("%d\t%d\t%d\t%d\t%d%n",
            currentTimeSeconds() - startTime,
            num,
            prevNum-num,
            totalCollisions-prevCollisions,
            (prevNum-num)*chainLength/(currentTimeSeconds() - curTime));
        curTime = currentTimeSeconds();
        prevCollisions = totalCollisions;
        prevNum = num;
      }
      String key = generateKey(); // Starting chain key
      // Hash from the end of a chain that starts with 'key'
      byte[] hash = hashToHashStep(createShaHash(key), (chainLength - 1));

      // If the hash already exists in hashToKeyMap, generate a new chain
      // I believe we should only collide here if two different
      // starting keys end up generating the same end hash.
      for (int i = 0; i < hashToKeyMap.size(); i++) {
        if (!hashToKeyMap.get(i).containsKey(hash)) {
          // Insert new chain in table
          keyToHashMap.get(i).put(key, hash);
          hashToKeyMap.get(i).put(hash, key);
          num--;
          break;
        } else {
          if(i == 1) {
//            System.out.println("Collision on table " + i);
            if(DEBUG) {
              totalCollisions++;
            }
          }
        }
      }
    }

    if(DEBUG) {
      System.out.println("Collisions: " + totalCollisions);
    }
  }

  /**
   * Returns the current system time in seconds.
   * @see System#currentTimeMillis()
   * @return Current time in seconds
   */
  protected long currentTimeSeconds() {
    return System.currentTimeMillis() / 1000L;
  }

  /**
   * Reduce then hash, <code>n</code> times.
   * @param initialHash Starting hash value
   * @param n Number of times to hash, reduce
   * @return Hash in byte[] form that is 'n' steps from 'initialHash'
   */
  protected byte[] hashToHashStep(byte[] initialHash, int n) {
    return hashToHashStep(initialHash, n, chainLength, keyLength);
  }

  /**
   * Randomly generates one key according to parameters in <code>Config</code> object,
   * provided at construction.
   * @see Config
   * @return String adhering to key space constraints
   */
  protected String generateKey() {
    String builtString; // Holds the key as it's built

    // Loop on the key building process until a key in generated that doesn't
    // match an existing key.
    boolean exists = false;
    do {
      builtString = "";
      for (int i = 0; i < keyLength; i++) {
        builtString +=
            ALLOWABLE_CHARS[ThreadLocalRandom.current().nextInt(0, ALLOWABLE_CHARS.length)];
      }
      for(int i = 0; i < keyToHashMap.size(); i++) {
        if(keyToHashMap.get(i).containsKey(builtString)) {
          exists = true;
        } else {
          exists = false;
          break;
        }
      }

    } while (exists);

    return builtString;
  }

  /**
   * Hash reduction algorithm. Produces different results depending on supplied <code>salt</code>.
   * @param hash Hash in byte[] form
   * @param salt int that acts as modifier to method's output
   * @return Plain-text key
   */
  protected String hashToKey(byte[] hash, int salt) {
    return Table.hashToKey(hash, salt, keyLength);
  }

  /**
   * Hash, reduce, n times, along a chain that starts with <code>initialKey</code>.
   * @param initialKey Initial plain-text key
   * @param n Number of times to hash, reduce
   * @return Result of 'n' hash, reduce steps
   */
  protected String keyToKeyStep(String initialKey, int n) {
    return Table.keyToKeyStep(initialKey, n, chainLength, keyLength);
  }

  // PRIVATE
  private boolean existsTableFile() {
    return Files.exists(Paths.get(fileName));
  }
  /**
   * Read in previously computed tables that match supplied <code>Config</code> object,
   * if it exists. <code>keyToHashMap</code> is read from file, <code>hashToKeyMap</code> is
   * constructed.
   * @see MessageUnpacker
   * @return Success or failure
   */
  private boolean readTableFile() {
    try {
      MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(new FileInputStream(fileName));
      // Load 'keyToHashMap', construct 'hashToKeyMap'
      int rbTables = unpacker.unpackArrayHeader(); // # of rainbow tables held
      for(int i = 0; i < rbTables; i++) {
        // Load the particular table
        int mapLength = unpacker.unpackMapHeader();
        for (int j = 0; j < mapLength; j++) {
          String key = unpacker.unpackString();
          byte[] hash = unpacker.readPayload(unpacker.unpackBinaryHeader());
          // Both maps hold the same data. Together they form a bidirectional map
          keyToHashMap.get(i).put(key, hash);
          hashToKeyMap.get(i).put(hash, key);
        }
      }
      unpacker.close();
    } catch (IOException e) {
      // The file doesn't exist
      return false;
    }
    return true;
  }

  /**
   * Serialize rainbow table(s) contained in 'keyToHashMap', write to disk. 'hashToKeyMap' comes
   * for free, as it can be reconstructed from 'keyToHashMap'.
   * @see MessagePack
   * @see MessagePacker
   */
  private void writeTableFile() {
    try {
      MessagePacker packer = MessagePack.newDefaultPacker(new FileOutputStream(fileName));

      // Write keyToHashMap
      packer.packArrayHeader(keyToHashMap.size());
      // For each rainbow table held...
      for(int i = 0; i < keyToHashMap.size(); i++) {
        // Store this particular table
        packer.packMapHeader(keyToHashMap.get(i).size());
        for (Map.Entry<String, byte[]> entry : keyToHashMap.get(i).entrySet()) {
          packer.packString(entry.getKey());
          packer.packBinaryHeader(entry.getValue().length);
          packer.writePayload(entry.getValue());
        }
      }
      packer.close();
    } catch (Exception e) {
      // We can continue, but their table is lost after program termination
      System.out.println("Error writing to disk.");
      e.printStackTrace();
    }
  }

  /**
   * <code>Comparator</code> for <code>byte[]</code>. This allows hashes in the form of
   * <code>byte[]</code> to be used as <code>TreeMap</code> keys.<br>
   * Credit to: https://stackoverflow.com/a/38552674/3846437
   * @see Comparator
   */
  protected static class ByteArrayComparator implements Comparator<byte[]> {
    @Override
    public int compare(byte[] o1, byte[] o2) {
      int result = 0;
      int maxLength = Math.max(o1.length, o2.length);
      for (int index = 0; index < maxLength; index++) {
        byte o1Value = index < o1.length ? o1[index] : 0;
        byte o2Value = index < o2.length ? o2[index] : 0;
        int cmp = Byte.compare(o1Value, o2Value);
        if (cmp != 0) {
          result = cmp;
          break;
        }
      }
      return result;
    }
  }
}